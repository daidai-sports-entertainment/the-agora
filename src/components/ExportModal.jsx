import { useState, useRef, useEffect } from 'react';
import { getText } from '../utils/i18n';
import { formatEra, formatRelationType } from '../utils/i18n';
import { getNodeColor } from '../utils/colorScheme';

/**
 * Export modal for generating shareable images
 * Creates a dual-panel layout: left=canvas visualization, right=details
 */
export function ExportModal({ isOpen, onClose, selectedNode, language, allNodes }) {
  const [isGenerating, setIsGenerating] = useState(false);
  const [previewImage, setPreviewImage] = useState(null);
  const canvasRef = useRef(null);
  const t = getText(language);

  useEffect(() => {
    if (isOpen && selectedNode) {
      generatePreview();
    }
  }, [isOpen, selectedNode]);

  const generatePreview = async () => {
    setIsGenerating(true);
    try {
      await new Promise(resolve => setTimeout(resolve, 100));

      const canvas = canvasRef.current;
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      const width = 1600;
      const height = 900;
      const leftPanelWidth = 1000;
      const rightPanelWidth = 600;
      const padding = 40;

      canvas.width = width;
      canvas.height = height;

      // Background
      ctx.fillStyle = '#0a0e1a';
      ctx.fillRect(0, 0, width, height);

      // === LEFT PANEL: Canvas Visualization ===
      drawCanvasVisualization(ctx, leftPanelWidth, height, selectedNode, allNodes);

      // === RIGHT PANEL: Details ===
      // Draw smooth gradient background for right panel
      const gradient = ctx.createLinearGradient(leftPanelWidth, 0, width, height);
      gradient.addColorStop(0, '#151b2e');
      gradient.addColorStop(0.5, '#1a2033');
      gradient.addColorStop(1, '#0d1117');
      ctx.fillStyle = gradient;
      ctx.fillRect(leftPanelWidth, 0, rightPanelWidth, height);

      drawDetailsPanel(ctx, leftPanelWidth, rightPanelWidth, height, selectedNode, allNodes, language, t, padding);

      // Elegant watermark
      const watermarkText = language === 'zh' ? 'Áî± Agora ÁîüÊàê' : 'Generated by Agora';
      ctx.fillStyle = 'rgba(230, 201, 138, 0.5)';
      ctx.font = 'italic 16px system-ui';
      ctx.textAlign = 'right';
      ctx.fillText(watermarkText, width - 30, height - 25);

      setPreviewImage(canvas.toDataURL('image/png'));
    } catch (error) {
      console.error('Error generating preview:', error);
    } finally {
      setIsGenerating(false);
    }
  };

  // Draw left panel: canvas visualization with selected node and its connections
  const drawCanvasVisualization = (ctx, width, height, selectedNode, allNodes) => {
    // Get related nodes
    const relatedNodeIds = new Set();
    relatedNodeIds.add(selectedNode.id);

    // Add outgoing connections
    selectedNode.relationships?.forEach(rel => {
      relatedNodeIds.add(rel.target);
    });

    // Add incoming connections
    allNodes.forEach(node => {
      node.relationships?.forEach(rel => {
        if (rel.target === selectedNode.id) {
          relatedNodeIds.add(node.id);
        }
      });
    });

    const relatedNodes = allNodes.filter(node => relatedNodeIds.has(node.id));

    // Calculate bounds to fit all related nodes
    if (relatedNodes.length === 0) return;

    // Use coordinates from main canvas (baseX, baseY already calculated)
    // This preserves the exact layout including clusters
    const margin = 40;

    // Calculate bounds from main canvas coordinates
    let minCanvasX = Infinity, maxCanvasX = -Infinity;
    let minCanvasY = Infinity, maxCanvasY = -Infinity;

    relatedNodes.forEach(node => {
      if (node.baseX !== undefined && node.baseY !== undefined) {
        minCanvasX = Math.min(minCanvasX, node.baseX);
        maxCanvasX = Math.max(maxCanvasX, node.baseX);
        minCanvasY = Math.min(minCanvasY, node.baseY);
        maxCanvasY = Math.max(maxCanvasY, node.baseY);
      }
    });

    // Add padding (10% - reduced for larger canvas)
    const canvasXPadding = (maxCanvasX - minCanvasX) * 0.1 || 50;
    const canvasYPadding = (maxCanvasY - minCanvasY) * 0.1 || 50;
    minCanvasX -= canvasXPadding;
    maxCanvasX += canvasXPadding;
    minCanvasY -= canvasYPadding;
    maxCanvasY += canvasYPadding;

    const canvasXRange = maxCanvasX - minCanvasX;
    const canvasYRange = maxCanvasY - minCanvasY;

    // Calculate scale to fit in left panel
    const panelWidth = width - 2 * margin;
    const panelHeight = height - 2 * margin;

    const scaleX = panelWidth / canvasXRange;
    const scaleY = panelHeight / canvasYRange;

    // Use uniform scale to maintain aspect ratio
    const scale = Math.min(scaleX, scaleY);

    // Calculate actual scaled dimensions
    const scaledWidth = canvasXRange * scale;
    const scaledHeight = canvasYRange * scale;

    // Center the content in the panel
    const offsetX = margin + (panelWidth - scaledWidth) / 2;
    const offsetY = margin + (panelHeight - scaledHeight) / 2;

    // Transform functions: main canvas coordinates ‚Üí export canvas coordinates (centered)
    const transformX = (baseX) => offsetX + (baseX - minCanvasX) * scale;
    const transformY = (baseY) => offsetY + (baseY - minCanvasY) * scale;

    // Draw stars background (subtle)
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    for (let i = 0; i < 50; i++) {
      const x = Math.random() * width;
      const y = Math.random() * height;
      const size = Math.random() * 1.5;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw connections - only lines connected to the selected node
    relatedNodes.forEach(node => {
      node.relationships?.forEach(rel => {
        const targetNode = allNodes.find(n => n.id === rel.target);
        if (targetNode && relatedNodeIds.has(targetNode.id)) {
          // Only draw if one end is the selected node
          if (node.id === selectedNode.id || targetNode.id === selectedNode.id) {
            const x1 = transformX(node.baseX);
            const y1 = transformY(node.baseY);
            const x2 = transformX(targetNode.baseX);
            const y2 = transformY(targetNode.baseY);

            ctx.strokeStyle = 'rgba(230, 201, 138, 0.5)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
          }
        }
      });
    });

    // Draw nodes - larger and more prominent
    relatedNodes.forEach(node => {
      const x = transformX(node.baseX);
      const y = transformY(node.baseY);
      const isSelected = node.id === selectedNode.id;
      const radius = isSelected ? 18 : 12;

      // Glow effect for selected node
      if (isSelected) {
        ctx.shadowColor = '#e6c98a';
        ctx.shadowBlur = 25;
      }

      // Node circle
      const color = getNodeColor(node);
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();

      ctx.shadowBlur = 0;

      // Label for all nodes
      ctx.fillStyle = '#e6c98a';
      ctx.font = isSelected ? 'bold 16px system-ui' : '14px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(node.name, x, y - radius - 10);
    });
  };

  // Draw right panel: details
  const drawDetailsPanel = (ctx, leftPanelWidth, panelWidth, height, selectedNode, allNodes, language, t, padding) => {
    const xStart = leftPanelWidth + padding;
    let yPos = padding + 30;

    // Title with shadow effect
    ctx.shadowColor = 'rgba(230, 201, 138, 0.3)';
    ctx.shadowBlur = 10;
    ctx.fillStyle = '#f5e6c8';
    ctx.font = 'bold 40px Georgia, serif';
    ctx.textAlign = 'left';
    wrapText(ctx, selectedNode.name, xStart, yPos, panelWidth - 2 * padding, 50);
    ctx.shadowBlur = 0;
    yPos += 75;

    // Era badge with rounded corners effect
    const era = formatEra(selectedNode.era, language);
    ctx.fillStyle = '#e6c98a';
    ctx.font = 'bold 18px system-ui';
    ctx.fillText('üìÖ ' + era, xStart, yPos);

    // Underline for era
    const eraTextWidth = ctx.measureText('üìÖ ' + era).width;
    ctx.fillStyle = 'rgba(230, 201, 138, 0.4)';
    ctx.fillRect(xStart, yPos + 5, eraTextWidth, 2);
    yPos += 50;

    // Description with quotation style
    ctx.fillStyle = 'rgba(230, 201, 138, 0.6)';
    ctx.font = 'italic 60px Georgia, serif';
    ctx.fillText('"', xStart - 10, yPos + 10);

    ctx.fillStyle = '#e8e8e8';
    ctx.font = 'italic 19px Georgia, serif';
    const descHeight = wrapText(ctx, selectedNode.description, xStart + 15, yPos + 10, panelWidth - 2 * padding - 30, 30);
    yPos += descHeight + 40;

    // Key figures
    if (selectedNode.key_figures && selectedNode.key_figures.length > 0) {
      yPos += 15;

      ctx.fillStyle = '#e6c98a';
      ctx.font = 'bold 20px system-ui';
      ctx.fillText('üë§ ' + t.keyFigures, xStart, yPos);
      yPos += 35;

      selectedNode.key_figures.slice(0, 3).forEach((figure) => {
        ctx.fillStyle = '#d4d4d4';
        ctx.font = '17px system-ui';
        ctx.fillText('‚Ä¢ ' + figure, xStart + 10, yPos);
        yPos += 28;
      });
      yPos += 20;
    }

    // Relationships
    const outgoing = selectedNode.relationships || [];
    const incoming = allNodes
      .filter(node => node.relationships?.some(rel => rel.target === selectedNode.id))
      .flatMap(node =>
        node.relationships
          .filter(rel => rel.target === selectedNode.id)
          .map(rel => ({ ...rel, sourceName: node.name }))
      );

    const totalRel = outgoing.length + incoming.length;

    yPos += 15;

    // Relationships header
    ctx.fillStyle = '#e6c98a';
    ctx.font = 'bold 24px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(`üîó ${language === 'zh' ? 'ÂÖ≥Á≥ªÁΩëÁªú' : 'Relationship Network'} (${totalRel})`, xStart, yPos);

    yPos += 40;

    // Influences
    if (outgoing.length > 0) {
      ctx.fillStyle = '#66bb6a';
      ctx.font = 'bold 19px system-ui';
      ctx.fillText(`üì§ ${language === 'zh' ? 'ÂΩ±Âìç' : 'Influences'} (${outgoing.length})`, xStart, yPos);
      yPos += 30;

      ctx.fillStyle = '#d4d4d4';
      ctx.font = '16px system-ui';
      outgoing.slice(0, 3).forEach(rel => {
        const text = formatRelationType(rel.type, language) + ' ‚Üí ' + formatNodeName(rel.target);
        wrapText(ctx, '  ‚Ä¢ ' + text, xStart + 10, yPos, panelWidth - 2 * padding - 10, 28);
        yPos += 28;
      });
      if (outgoing.length > 3) {
        ctx.fillStyle = '#9ca3af';
        ctx.font = 'italic 15px system-ui';
        ctx.fillText(`  ... +${outgoing.length - 3} more`, xStart + 10, yPos);
        yPos += 28;
      }
      yPos += 20;
    }

    // Influenced By
    if (incoming.length > 0) {
      ctx.fillStyle = '#64b5f6';
      ctx.font = 'bold 19px system-ui';
      ctx.fillText(`üì• ${language === 'zh' ? 'Ë¢´ÂΩ±Âìç' : 'Influenced By'} (${incoming.length})`, xStart, yPos);
      yPos += 30;

      ctx.fillStyle = '#d4d4d4';
      ctx.font = '16px system-ui';
      incoming.slice(0, 3).forEach(rel => {
        const text = formatRelationType(rel.type, language) + ' ‚Üê ' + rel.sourceName;
        wrapText(ctx, '  ‚Ä¢ ' + text, xStart + 10, yPos, panelWidth - 2 * padding - 10, 28);
        yPos += 28;
      });
      if (incoming.length > 3) {
        ctx.fillStyle = '#9ca3af';
        ctx.font = 'italic 15px system-ui';
        ctx.fillText(`  ... +${incoming.length - 3} more`, xStart + 10, yPos);
      }
    }
  };

  // Helper to wrap text and return height used
  const wrapText = (ctx, text, x, y, maxWidth, lineHeight) => {
    const words = text.split(' ');
    let line = '';
    let currentY = y;
    let lines = 0;

    for (let i = 0; i < words.length; i++) {
      const testLine = line + words[i] + ' ';
      const metrics = ctx.measureText(testLine);

      if (metrics.width > maxWidth && i > 0) {
        ctx.fillText(line, x, currentY);
        line = words[i] + ' ';
        currentY += lineHeight;
        lines++;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line, x, currentY);
    lines++;

    return lines * lineHeight;
  };

  const formatNodeName = (name) => {
    return name
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  };

  const handleExportPNG = () => {
    if (!previewImage) return;

    const link = document.createElement('a');
    link.download = `agora-${selectedNode.id}-${Date.now()}.png`;
    link.href = previewImage;
    link.click();
  };

  if (!isOpen) return null;

  return (
    <div style={styles.overlay} onClick={onClose}>
      <canvas ref={canvasRef} style={{ display: 'none' }} />
      <div style={styles.modal} onClick={e => e.stopPropagation()}>
        <div style={styles.header}>
          <h2 style={styles.title}>
            {language === 'zh' ? 'ÂØºÂá∫ÂàÜ‰∫´' : 'Export & Share'}
          </h2>
          <button
            type="button"
            onClick={onClose}
            style={styles.closeButton}
            aria-label="Close"
          >
            ‚úï
          </button>
        </div>

        <div style={styles.content}>
          {isGenerating ? (
            <div style={styles.loading}>
              <div style={styles.spinner}></div>
              <p style={styles.loadingText}>
                {language === 'zh' ? 'ÁîüÊàêÈ¢ÑËßà‰∏≠...' : 'Generating preview...'}
              </p>
            </div>
          ) : previewImage ? (
            <div style={styles.preview}>
              <img
                src={previewImage}
                alt="Preview"
                style={styles.previewImage}
              />
            </div>
          ) : (
            <div style={styles.error}>
              {language === 'zh' ? 'È¢ÑËßàÁîüÊàêÂ§±Ë¥•' : 'Failed to generate preview'}
            </div>
          )}
        </div>

        <div style={styles.footer}>
          <button
            type="button"
            onClick={handleExportPNG}
            disabled={!previewImage || isGenerating}
            style={{
              ...styles.exportButton,
              ...styles.pngButton,
              ...((!previewImage || isGenerating) ? styles.disabledButton : {})
            }}
          >
            <span style={styles.buttonIcon}>üì•</span>
            {language === 'zh' ? 'ÂØºÂá∫ÂõæÁâá' : 'Export Image'}
          </button>
        </div>
      </div>
    </div>
  );
}

const styles = {
  overlay: {
    position: 'fixed',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.85)',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 2000,
    backdropFilter: 'blur(8px)'
  },
  modal: {
    backgroundColor: 'rgba(14, 20, 34, 0.98)',
    borderRadius: '16px',
    border: '1px solid rgba(230, 201, 138, 0.2)',
    boxShadow: '0 20px 60px rgba(0, 0, 0, 0.5)',
    maxWidth: '95vw',
    maxHeight: '95vh',
    width: '1400px',
    display: 'flex',
    flexDirection: 'column',
    overflow: 'hidden'
  },
  header: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: '24px',
    borderBottom: '1px solid rgba(230, 201, 138, 0.2)'
  },
  title: {
    fontSize: '24px',
    fontWeight: 600,
    color: 'var(--color-accent)',
    margin: 0,
    fontFamily: 'var(--font-title)'
  },
  closeButton: {
    width: '40px',
    height: '40px',
    borderRadius: '8px',
    border: '1px solid rgba(230, 201, 138, 0.3)',
    backgroundColor: 'transparent',
    color: 'var(--color-accent)',
    fontSize: '20px',
    cursor: 'pointer',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    transition: 'all 0.2s ease'
  },
  content: {
    flex: 1,
    padding: '24px',
    overflow: 'auto',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
  },
  loading: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    gap: '16px'
  },
  spinner: {
    width: '48px',
    height: '48px',
    border: '4px solid rgba(230, 201, 138, 0.2)',
    borderTop: '4px solid var(--color-accent)',
    borderRadius: '50%',
    animation: 'spin 1s linear infinite'
  },
  loadingText: {
    color: 'var(--color-muted)',
    fontSize: '14px'
  },
  preview: {
    position: 'relative',
    maxWidth: '100%',
    maxHeight: '100%',
    borderRadius: '8px',
    overflow: 'hidden',
    boxShadow: '0 10px 40px rgba(0, 0, 0, 0.3)'
  },
  previewImage: {
    width: '100%',
    height: 'auto',
    display: 'block'
  },
  error: {
    color: 'var(--color-muted)',
    fontSize: '16px',
    textAlign: 'center'
  },
  footer: {
    display: 'flex',
    gap: '16px',
    padding: '24px',
    borderTop: '1px solid rgba(230, 201, 138, 0.2)',
    justifyContent: 'flex-end'
  },
  exportButton: {
    padding: '12px 24px',
    borderRadius: '8px',
    border: 'none',
    fontSize: '14px',
    fontWeight: 600,
    cursor: 'pointer',
    display: 'flex',
    alignItems: 'center',
    gap: '8px',
    transition: 'all 0.2s ease',
    letterSpacing: '0.3px'
  },
  pngButton: {
    backgroundColor: 'rgba(230, 201, 138, 0.2)',
    color: 'var(--color-accent)',
    border: '1px solid rgba(230, 201, 138, 0.4)'
  },
  disabledButton: {
    opacity: 0.5,
    cursor: 'not-allowed'
  },
  buttonIcon: {
    fontSize: '18px'
  }
};
