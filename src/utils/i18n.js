export const TEXT = {
  en: {
    appTitle: 'The Agora',
    tagline: 'Observe how ideas relate, respond, and diverge within history\'s universe.',
    legendTitle: 'Legend',
    legendPhilosophy: 'Philosophy',
    legendPolitics: 'Politics',
    legendInterdisciplinary: 'Philosophy + Politics',
    instructionsTitle: 'How to Use',
    instructions: [
      'Click nodes to view details',
      'Scroll to zoom',
      'Drag to pan view',
      'Click background to deselect'
    ],
    stats: (count) => [
      `ğŸ“š ${count} concepts`,
      'Ideas appear close because they are discussed in similar contexts, not because they agree.'
    ],
    proximityNote:
      'Ideas appear close because they are discussed in similar contexts, not because they agree.',
    searchPlaceholder: 'Search concepts...',
    description: 'Description',
    keyFigures: 'Key Figures',
    domains: 'Domains',
    relationships: 'Relationships',
    moreRelationships: (count) => `... and ${count} more relationships`,
    languageLabel: 'Language',
    languageEN: 'EN',
    languageZH: 'ä¸­æ–‡',
    welcomeTitle: 'Welcome to The Agora',
    welcomeMessage:
      'Explore the evolution of philosophical and political thought from ancient to contemporary times. Click any node to begin your journey.',
    welcomeFeatures: [
      'Click nodes to reveal connections',
      'Scroll to zoom and drag to pan',
      'View details in the side panel'
    ],
    startExploring: 'Start Exploring',
    loadingTitle: 'Loading The Agora...',
    loadingSubtitle: 'Mapping the landscape of ideas from ancient to contemporary thought',
    eraBCE: 'BCE',
    eraCE: 'CE',
    categoryPhilosophy: 'Philosophy',
    categoryPolitics: 'Politics',
    categoryBoth: 'Philosophy + Politics',
    axisLabel: 'â† Semantic Similarity â†’',
    eraNames: ['Ancient', 'Medieval', 'Enlightenment', 'Modern', 'Contemporary']
  },
  zh: {
    appTitle: 'The Agora Â· æ€æƒ³æ˜Ÿå›¾',
    tagline: 'åœ¨å†å²çš„å®‡å®™ä¸­ï¼Œæ¢ç´¢æ€æƒ³å¦‚ä½•å¯¹è¯ä¸åˆ†åŒ–ã€‚',
    legendTitle: 'å›¾ä¾‹',
    legendPhilosophy: 'å“²å­¦',
    legendPolitics: 'æ”¿æ²»',
    legendInterdisciplinary: 'å“²å­¦ + æ”¿æ²»',
    instructionsTitle: 'ä½¿ç”¨æ–¹å¼',
    instructions: [
      'ç‚¹å‡»èŠ‚ç‚¹æŸ¥çœ‹è¯¦æƒ…',
      'æ»šè½®ç¼©æ”¾',
      'æ‹–æ‹½å¹³ç§»è§†å›¾',
      'ç‚¹å‡»èƒŒæ™¯å–æ¶ˆé€‰æ‹©'
    ],
    stats: (count) => [
      `ğŸ“š ${count} ä¸ªæ¦‚å¿µ`,
      'æ€æƒ³ä¹‹æ‰€ä»¥é è¿‘ï¼Œæ˜¯å› ä¸ºå®ƒä»¬å¸¸å‡ºç°åœ¨ç›¸ä¼¼çš„è®¨è®ºè¯­å¢ƒä¸­ï¼Œè€Œä¸æ˜¯å› ä¸ºç«‹åœºä¸€è‡´ã€‚'
    ],
    proximityNote:
      'æ€æƒ³ä¹‹æ‰€ä»¥é è¿‘ï¼Œæ˜¯å› ä¸ºå®ƒä»¬å¸¸å‡ºç°åœ¨ç›¸ä¼¼çš„è®¨è®ºè¯­å¢ƒä¸­ï¼Œè€Œä¸æ˜¯å› ä¸ºç«‹åœºä¸€è‡´ã€‚',
    searchPlaceholder: 'æœç´¢æ€æƒ³æ¦‚å¿µ...',
    description: 'æ¦‚å¿µè¯´æ˜',
    keyFigures: 'å…³é”®äººç‰©',
    domains: 'é¢†åŸŸ',
    relationships: 'å…³ç³»',
    moreRelationships: (count) => `è¿˜æœ‰ ${count} æ¡å…³ç³»`,
    languageLabel: 'è¯­è¨€',
    languageEN: 'EN',
    languageZH: 'ä¸­æ–‡',
    welcomeTitle: 'æ¬¢è¿æ¥åˆ°æ€æƒ³æ˜Ÿå›¾',
    welcomeMessage:
      'ä»å¤å…¸å“²å­¦åˆ°å½“ä»£ç†è®ºï¼Œæ¢ç´¢æ€æƒ³æ¼”è¿›çš„è½¨è¿¹ã€‚ç‚¹å‡»ä»»æ„èŠ‚ç‚¹ï¼Œå¼€å¯ä½ çš„æ˜Ÿé™…å‘ç°ã€‚',
    welcomeFeatures: [
      'ç‚¹å‡»èŠ‚ç‚¹å‘ˆç°æ€æƒ³å…³è”',
      'æ»šè½®ç¼©æ”¾ï¼Œæ‹–æ‹½å¹³ç§»',
      'åœ¨å³ä¾§é¢æ¿æŸ¥çœ‹è¯¦æƒ…'
    ],
    startExploring: 'å¼€å§‹æ¢ç´¢',
    loadingTitle: 'æ­£åœ¨æ„å»ºæ€æƒ³æ˜Ÿå›¾...',
    loadingSubtitle: 'ä»å¤ä»£åˆ°å½“ä»£çš„æ€æƒ³è„‰ç»œæ­£åœ¨è¢«ç‚¹äº®',
    eraBCE: 'å…¬å…ƒå‰',
    eraCE: 'å…¬å…ƒ',
    categoryPhilosophy: 'å“²å­¦',
    categoryPolitics: 'æ”¿æ²»',
    categoryBoth: 'å“²å­¦ + æ”¿æ²»',
    axisLabel: 'â† è¯­ä¹‰ç›¸ä¼¼åº¦ â†’',
    eraNames: ['å¤ä»£', 'ä¸­ä¸–çºª', 'å¯è’™', 'ç°ä»£', 'å½“ä»£']
  }
};

const RELATIONSHIP_LABELS = {
  en: {
    influenced_by: 'Influenced By',
    influenced: 'Influenced',
    opposes: 'Opposes',
    similar_to: 'Similar To',
    evolved_from: 'Evolved From',
    evolved_into: 'Evolved Into',
    synthesized_with: 'Synthesized With',
    foundation_for: 'Foundation For',
    critiques: 'Critiques',
    built_on: 'Built On',
    moderate_form: 'Moderate Form',
    diverged_from: 'Diverged From',
    radicalized_into: 'Radicalized Into',
    preceded: 'Preceded',
    succeeded: 'Succeeded',
    challenged_by: 'Challenged By',
    challenged: 'Challenged',
    incorporated_into: 'Incorporated Into',
    reacted_against: 'Reacted Against',
    inspired: 'Inspired',
    inspired_by: 'Inspired By',
    based_on: 'Based On'
  },
  zh: {
    influenced_by: 'å—å…¶å½±å“',
    influenced: 'å½±å“äº†',
    opposes: 'å¯¹ç«‹',
    similar_to: 'ç›¸ä¼¼',
    evolved_from: 'æ¼”åŒ–è‡ª',
    evolved_into: 'æ¼”åŒ–ä¸º',
    synthesized_with: 'ç»¼åˆäº',
    foundation_for: 'å¥ åŸºäº',
    critiques: 'æ‰¹åˆ¤',
    built_on: 'å»ºç«‹äº',
    moderate_form: 'æ¸©å’Œå½¢å¼',
    diverged_from: 'åˆ†åŒ–è‡ª',
    radicalized_into: 'æ¿€è¿›åŒ–ä¸º',
    preceded: 'å…ˆäº',
    succeeded: 'ç»§æ‰¿è‡ª',
    challenged_by: 'å—åˆ°æŒ‘æˆ˜',
    challenged: 'æŒ‘æˆ˜äº†',
    incorporated_into: 'å¹¶å…¥',
    reacted_against: 'åæ€',
    inspired: 'å¯å‘',
    inspired_by: 'å—å¯å‘',
    based_on: 'åŸºäº'
  }
};

const DOMAIN_LABELS = {
  en: {
    philosophy: 'Philosophy',
    politics: 'Politics'
  },
  zh: {
    philosophy: 'å“²å­¦',
    politics: 'æ”¿æ²»'
  }
};

export function getText(language) {
  return TEXT[language] || TEXT.en;
}

export function formatEra(era, language) {
  const t = getText(language);
  if (era < 0) {
    return language === 'zh'
      ? `${t.eraBCE}${Math.abs(era)}`
      : `${Math.abs(era)} ${t.eraBCE}`;
  }
  return language === 'zh' ? `${t.eraCE}${era}` : `${era} ${t.eraCE}`;
}

export function formatCategory(domains, language) {
  const t = getText(language);
  const hasPolitics = domains.includes('politics');
  const hasPhilosophy = domains.includes('philosophy');

  if (hasPolitics && hasPhilosophy) {
    return t.categoryBoth;
  }
  return hasPolitics ? t.categoryPolitics : t.categoryPhilosophy;
}

export function formatRelationType(type, language) {
  const map = RELATIONSHIP_LABELS[language] || RELATIONSHIP_LABELS.en;
  if (map[type]) {
    return map[type];
  }

  return type
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

export function formatDomain(domain, language) {
  const map = DOMAIN_LABELS[language] || DOMAIN_LABELS.en;
  return map[domain] || domain;
}
